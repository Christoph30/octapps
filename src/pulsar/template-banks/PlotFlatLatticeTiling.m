## Copyright (C) 2012 Karl Wette
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with with program; see the file COPYING. If not, write to the
## Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
## MA  02111-1307  USA

## Plot a flat lattice tiling generated by TestFlatLatticeTiling.
## Usage:
##   PlotFlatLatticeTiling(res, p, what, [options])
## where
##   res = results structure returned by TestFlatLatticeTiling()
##   p = vector of dimensionality of parameter space, whose elements are:
##     NaN: these dimensions are plotted (must be exactly 2 of them)
##     <value>: these dimensions are intersected by the plane <value>
##     Inf: all points in these dimensions are included
##   what = string of characters which determines what to plot:
##     t: plot intersection ellipse centres of all templates, or templates which have been hit
##     T: plot intersection ellipse centres of templates which have not been hit
##     e: plot intersection ellipses of all templates, or templates which have been hit
##     E: plot intersection ellipses of templates which have not been hit
##     F: plot intersection ellipses of templates which have been hit by non-covered injections
##     i: plot injections which are covered by an intersected template
##     I: plot injections which are not covered by an intersected template
##     n: plot lines from covered injections to their nearest template
##     N: plot lines from non-covered injections to their nearest template
## Additional options are:
##   "bounds": parameter space bounds to plot, as 2xN matrix of points
##   "Nsteps":  number of plotting points per mismatch ellipse surface direction (20)

function PlotFlatLatticeTiling(res, p, what, varargin)

  ## check res
  assert(isstruct(res));
  assert(issquare(res.metric));
  assert(!isempty(res.templates));

  ## check p
  assert(isvector(p));
  assert(length(p) == size(res.metric, 1));
  assert(p(isinf(p)) > 0);

  ## check what
  assert(ischar(what));
  injwhat = strchr(what, "TIEFNin");
  if !isempty(injwhat) && isempty(res.injections)
    error("%s: '%s' option(s) require(s) injection points", funcName, what(injwhat));
  endif

  ## check options
  parseOptions(varargin,
               {"bounds", "real,matrix", []},
               {"Nsteps", "strictpos,integer", 20},
               []);
  assert(isempty(bounds) || size(bounds, 1) == 2);

  ## NaN values of p indicate dimensions to plot; can only plot 2 dimensions
  ## non-NaN values of p gives constant values of other dimensions
  p = p(:);
  ii = isnan(p);
  jj = isfinite(p);
  if length(find(ii)) != 2
    error("%s: can only plot 2 dimensions, i.e. p can only contain 2 NaNs", funcName);
  endif

  ## diagonally normalise metric
  [metric, diagnorm, idiagnorm] = DiagonalNormaliseMetric(res.metric);

  ## partition metric into plotting and non-plotting dimensions
  Ma = metric(ii, ii);
  Mb = metric(ii, jj);
  Mc = metric(jj, jj);

  ## calculate template offsets from plotting plane in non-plotting dimensions
  y = idiagnorm(jj, jj) * (res.templates(jj, :) - p(jj, ones(1, size(res.templates, 2))));

  ## calculate centre offsets of metric ellipses in plotting plane
  x0 = Ma \ Mb * y;

  ## calculate effective mismatches of templates in plotting plane
  mu = res.max_mismatch - dot(y, Mc * y, 1) + dot(x0, Ma * x0, 1);

  ## get indices of templates which need to be plotted
  kk = (mu > 0.0);
  if !any(kk)
    error("%s: could not find any templates to plot with p=[%s ]", funcName, sprintf(" %g", p));
  endif

  ## calculate templates centres in plotting plane
  templates = res.templates(ii, :) + diagnorm(ii, ii) * x0;

  ## get injections
  if !isempty(res.injections)
    injections = res.injections(ii, :);
  endif

  ## get indices of intersected templates which have/have not been hit by an injection
  if !isempty(res.injections)
    hit_kk = false(size(kk));
    hit_kk(res.nearest_index) = true;
    nohit_kk = !hit_kk;
    hit_kk &= kk;
    nohit_kk &= kk;
  else
    hit_kk = kk;
  endif

  ## get indices of injections which are/are not covered by an intersected template
  if !isempty(res.injections)
    cvr_kk = (res.min_mismatch <= res.max_mismatch);
    nocvr_kk = !cvr_kk;
    cvr_kk &= kk(res.nearest_index);
    nocvr_kk &= kk(res.nearest_index);
    hitcvr_kk = res.nearest_index(cvr_kk);
    hitnocvr_kk = res.nearest_index(nocvr_kk);
  endif

  ## clear current figure and prepare for plotting
  clf;
  hold on;

  ## plot intersection ellipse centres of all templates, or templates which have been hit
  if any(what == "t")
    tmpl = templates(:, find(hit_kk))';
    tmpl = unique(tmpl, "rows");
    plot(tmpl(1, :), tmpl(2, :), "b*");
  endif

  ## plot intersection ellipse centres of templates which have not been hit
  if any(what == "T")
    tmpl = templates(:, find(nohit_kk))';
    tmpl = unique(tmpl, "rows");
    plot(tmpl(:, 1), tmpl(:, 2), "c*");
  endif

  ## plot intersection ellipses of all templates, or templates which have been hit
  if any(what == "e")
    tmpl = templates(:, find(hit_kk))';
    tmplmu = mu(find(hit_kk));
    [tmpl, tmplii] = unique(tmpl, "rows");
    tmplmu = mu(tmplii);
    for k = 1:size(tmpl, 1);
      [x, y] = metricEllipsoid(res.metric(ii, ii), tmplmu(k), Nsteps);
      plot(x + tmpl(k, 1), y + tmpl(k, 2), "b-");
    endfor
  endif

  ## plot intersection ellipses of templates which have not been hit
  if any(what == "E")
    tmpl = templates(:, find(nohit_kk))';
    tmplmu = mu(find(nohit_kk));
    [tmpl, tmplii] = unique(tmpl, "rows");
    tmplmu = mu(tmplii);
    for k = 1:size(tmpl, 1);
      [x, y] = metricEllipsoid(res.metric(ii, ii), tmplmu(k), Nsteps);
      plot(x + tmpl(k, 1), y + tmpl(k, 2), "c-");
    endfor
  endif

  ## plot intersection ellipses of templates which have been hit by non-covered injections
  if any(what == "F")
    tmpl = templates(:, find(hitnocvr_kk))';
    tmplmu = mu(find(hitnocvr_kk));
    [tmpl, tmplii] = unique(tmpl, "rows");
    tmplmu = mu(tmplii);
    for k = 1:size(tmpl, 1);
      [x, y] = metricEllipsoid(res.metric(ii, ii), tmplmu(k), Nsteps);
      plot(x + tmpl(k, 1), y + tmpl(k, 2), "r-");
    endfor
  endif

  ## plot injections which are covered by an intersected template
  if any(what == "i")
    plot(injections(1, cvr_kk), injections(2, cvr_kk), "kx");
  endif

  ## plot injections which are not covered by an intersected template
  if any(what == "I")
    plot(injections(1, nocvr_kk), injections(2, nocvr_kk), "rx");
  endif

  ## plot lines from covered injections to their nearest template
  if any(what == "n")
    x = [injections(1, cvr_kk); templates(1, hitcvr_kk); nan(1, length(hitcvr_kk))];
    y = [injections(2, cvr_kk); templates(2, hitcvr_kk); nan(1, length(hitcvr_kk))];
    plot(x(:), y(:), "k-");
  endif

  ## plot lines from non-covered injections to their nearest template
  if any(what == "N")
    x = [injections(1, nocvr_kk); templates(1, hitnocvr_kk); nan(1, length(hitnocvr_kk))];
    y = [injections(2, nocvr_kk); templates(2, hitnocvr_kk); nan(1, length(hitnocvr_kk))];
    plot(x(:), y(:), "k-");
  endif

  ## plot parameter space bounds, if given
  if !isempty(bounds)
    h = plot(bounds(1, :), bounds(2, :), "k-");
    set(h, "linewidth", 3 * get(h, "linewidth"));
  endif

  ## close plotting
  hold off;
  axis tight;

endfunction
